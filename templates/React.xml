<templateSet group="React">
  <template name="arrayreducer" value="function $ENTITY_LOWER$Reducer(state, action) {&#10;    if (('undefined' == typeof state) || (null == state)) {&#10;        return { isFetching: false, valid: false, updatedAt: null, items: [] };&#10;    }&#10;&#10;    if ('INIT' == action.type) {&#10;        if (localStorage.$ENTITY_LOWER$) {&#10;            return Object.assign({}, state, JSON.parse(localStorage.$ENTITY_LOWER$));&#10;        }&#10;    }&#10;&#10;    const $ENTITY_LOWER_SINGULAR$ = new normalizr.Schema('$ENTITY_LOWER$');&#10;&#10;    let data = null;&#10;&#10;    switch (action.type) {&#10;        case $ACTION$_REQUEST:&#10;            state = $.extend(true, {}, state, {&#10;                isFetching: true&#10;            });&#10;            break;&#10;        case $ACTION$_RECIEVE:&#10;            data = normalizer.normalize(action.payload, normalizr.arrayOf($ENTITY_LOWER_SINGULAR$));&#10;            state = $.extend(true, {}, state, {&#10;                isFetching: false,&#10;                valid: true,&#10;                updatedAt: moment(),&#10;                items: data.result&#10;            });&#10;            break;&#10;        case $ACTION$_ERROR:&#10;            state = $.extend(true, {}, state, {&#10;                isFetching: false&#10;            });&#10;            break;&#10;        case $ACTION$_INVALIDATE:&#10;            state = $.extend(true, {}, state, {&#10;                valid: false&#10;            });&#10;            break;&#10;    }&#10;&#10;    localStorage.setItem('$ENTITY_LOWER$', JSON.stringify(state));&#10;&#10;    return state;&#10;}" description="Array reducer" toReformat="false" toShortenFQNames="true">
    <variable name="ENTITY_LOWER" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="ENTITY_LOWER_SINGULAR" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="ACTION" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_SCRIPT" value="true" />
    </context>
  </template>
  <template name="arrayfetchactions" value="const USER_MESSAGES_REQUEST = 'user-messages.request';&#10;const USER_MESSAGES_RECIEVE = 'user-messages.recieve';&#10;const USER_MESSAGES_ERROR = 'user-messages.error';&#10;const USER_MESSAGES_INVALIDATE = 'user-messages.invalidate';&#10;&#10;function requestUserMessages(user) {&#10;    return {&#10;        type: USER_MESSAGES_REQUEST&#10;    }&#10;}&#10;&#10;function recieveUserMessages(response, user) {&#10;    return {&#10;        type: USER_MESSAGES_RECIEVE,&#10;        payload: response&#10;    }&#10;}&#10;&#10;function errorUserMessages(user) {&#10;    return {&#10;        type: USER_MESSAGES_ERROR&#10;    }&#10;}&#10;&#10;function invalidateUserMessages(user) {&#10;    return {&#10;        type: USER_MESSAGES_INVALIDATE&#10;    }&#10;}&#10;&#10;function fetchUserMessages(user) {&#10;    return function(dispatch) {&#10;        dispatch(requestUserMessages(user));&#10;        return Ajax.fetch({&#10;            url: BASE_URL + '/api/v1/users/' + user.id + '/messages.json?limit=10'&#10;        })&#10;        .then(response =&gt; {&#10;            response = $.map(response, function(value, index) {&#10;               return value;&#10;            });&#10;            dispatch(recieveUserMessages(response, user));&#10;        }, reason =&gt; {&#10;            dispatch(errorUserMessages(user));&#10;        });&#10;    }&#10;}&#10;&#10;function shouldFetchUserMessages(state) {&#10;    return !state.userMessages.isFetching&#10;        &amp;&amp; (&#10;            !state.userMessages.valid&#10;            || (null == state.userMessages.updatedAt)&#10;            || (moment().diff(state.userMessages.updatedAt) &gt; 10000)&#10;        )&#10;}&#10;&#10;function fetchUserMessagesIfNeeded(user) {&#10;    return function(dispatch, getState) {&#10;        if (shouldFetchUserMessages(getState(), user)) {&#10;            return dispatch(fetchUserMessages(user))&#10;        }&#10;    }&#10;}&#10;" description="Array fetch actions" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="JAVA_SCRIPT" value="true" />
    </context>
  </template>
  <template name="postitemactions" value="const $ACTION$_POST_REQUEST = 'user-messages.post.request';&#10;const $ACTION$_POST_RECIEVE = 'user-messages.post.recieve';&#10;&#10;function requestPost$ENTITY$(data) {&#10;    return {&#10;        type: $ACTION$_POST_REQUEST&#10;    }&#10;}&#10;&#10;function recievePost$ENTITY$(response, data) {&#10;    return {&#10;        type: $ACTION$_POST_RECIEVE,&#10;        payload: response&#10;    }&#10;}&#10;&#10;function post$ENTITY$(data) {&#10;    return function(dispatch) {&#10;        dispatch(requestPost$ENTITY$(data));&#10;        return Ajax.fetch({&#10;            type: 'POST',&#10;            url: BASE_URL + '/api/v1/',&#10;            data: data&#10;        })&#10;        .then(response =&gt; {&#10;            dispatch(recievePost$ENTITY$(response, data));&#10;        });&#10;    }&#10;}&#10;" description="Post item actions" toReformat="false" toShortenFQNames="true">
    <variable name="ACTION" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="ENTITY" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="JAVA_SCRIPT" value="true" />
    </context>
  </template>
</templateSet>